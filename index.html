<!DOCTYPE html>
<html lang="es">
<head>
    <title> Basic WebGL2 Scene</title>

    <script type="text/javascript" src="gl-matrix-min.js"></script>

    <script type="text/javascript" src="shaderManager.js"></script>
    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="models.js"></script>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js" ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.5/dat.gui.min.js" ></script>
    
    <script id="vs" type="x-shader/x-vertex">
        #version 300 es

        in vec3 position;
        in vec3 color;
        in vec3 normal;

        uniform mat4 projection;
        uniform mat4 view;
        uniform mat4 model;

        out vec3 vColor;
        out vec3 vNormal;
        out vec3 vPos;

        void main(void) 
        {
            mat4 modelView = view * model;
            vPos = (model * vec4(position,1.)).xyz;
            gl_Position = projection * modelView*vec4(position, 1.);

            vColor = color;
            vNormal = mat3(transpose(inverse(model))) * normal;
            //vNormal = normal;
        }
    </script>

    <script id="fs" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec3 vColor;
        in vec3 vNormal;
		in vec3 vPos;

        uniform vec3 camPos;
        uniform float outlineWidth;

         //Obj
        vec3 Ka;
        vec3 Kd;
        vec3 Ks;
        float brightness;
        vec3 Ke;
        vec3 pos;
		vec3 normalVector;

		//Parametros de la niebla
		vec3 cfog = vec3(1.0);
		float df = 0.03;


		// Luces

		//Parametros de luz globales
		float c1 = 1.0f;
		float c2 = 0.0f;
		float c3 = 0.1;
        #define MAX_LIGHTS 10
        int numLights;
        struct Light {
           vec4 position;
           vec3 intensities;
           float constAtt;
           float linearAtt;
           float cuadraticAtt;
           vec3 Ia;
           float coneAngle;
           vec3 coneDir;
        };

        //Parametros de la luz 1 - Point
        vec3 Il1 = vec3(0.6);
        vec3 Ia1 = vec3(0.2);
        vec3 pl1 = vec3(0,0,3);
        float att1 = 0.0;

		//light parameters 3 - Directional
		vec3 dir = vec3(0.0, 0.0, 1.0);
		vec3 Il3 = vec3(0.6);
		vec3 Ia3 = vec3(0.2);

        out vec4 outColor;

        vec3 shade2(Light[MAX_LIGHTS] lights) {
            vec3 c = vec3(0.0);
	        c+= Ke;

	       vec3 V = normalize(pos - camPos);

	       if (dot(V,normalVector) < 0.4f && dot(V,normalVector) > -0.4f ) {
	            return vec3(0.0f);
	        }

	        for (int i=0; i< numLights; i++ ) {
		        Light light = lights[i];
		        //Amibent
		        vec3 Iamb = Ka * light.Ia;
		        vec3 resi = Iamb;


		        vec3 L = normalize(light.position.xyz - pos * light.position.w); //point or directional
		        vec3 D = normalize(light.coneDir);
		        float cosLD = dot(-L,D);

		        if(cosLD >= cos(radians(light.coneAngle))) { // No se ilumninan fragmentos innecesarios
			        //Diff
			        vec3 Idiff = Kd * light.intensities * max(dot(normalVector,L),0.0);
			        Idiff = clamp(Idiff,0.0,1.0);

			        //Especular
			        vec3 H = normalize(V+L);
			        vec3 Ispec = Ks * light.intensities * pow( max( dot(H,normalVector), 0.0), brightness);

			        Ispec = clamp(Ispec,0.0,1.0);
			        resi += (Ispec + Idiff);
		        }

		        if ( light.position.w == 1.0) {
			        float d = length(light.position.xyz - pos);
			        resi /= light.constAtt + ( light.linearAtt * d) +( light.cuadraticAtt * pow(d,2.0f));
		        }
		        c += resi;
	        }

	        float f = exp(-pow(df*pos.z,2.0f));
	        c = f*c + (1.0f-f) * cfog;
	        return  c;
        }

        vec3 shade(Light[MAX_LIGHTS] lights) {
	        vec3 c = vec3(0.0);
	        c+= Ke;

	        vec3 V = normalize(pos - camPos);

	        if (dot(V,normalVector) < outlineWidth && dot(V,normalVector) > -0.1f ) {
	            return vec3(0.0f);
	        }

	        for (int i=0; i< numLights; i++ ) {
		        Light light = lights[i];
		        //Amibent
		        vec3 Iamb = Ka * light.Ia;
		        vec3 resi = Iamb;


		        vec3 L = normalize(light.position.xyz - pos * light.position.w); //point or directional
		        vec3 D = normalize(light.coneDir);
		        float cosLD = dot(-L,D);

		        if(cosLD >= cos(radians(light.coneAngle))) { // No se ilumninan fragmentos innecesarios
			        //Diff
			        vec3 Idiff = Kd * light.intensities * max(dot(normalVector,L),0.0);
			        Idiff = clamp(Idiff,0.0,1.0);

			        //Especular
			        vec3 R = -reflect(L,normalVector);
			        vec3 Ispec = Ks * light.intensities * pow( max( dot(V,R), 0.0), brightness);
			        Ispec = clamp(Ispec,0.0,1.0);
			        resi += (Ispec + Idiff);
		        }

		        if ( light.position.w == 1.0) {
			        float d = length(light.position.xyz - pos);
			        resi /= light.constAtt + ( light.linearAtt * d) +( light.cuadraticAtt * pow(d,2.0f));
		        }
		        c += resi;
	        }

	        float f = exp(-pow(df*pos.z,2.0f));
	        c = f*c + (1.0f-f) * cfog;
	        return  c;
	     }

        void main(void)
        {
            Ka = vColor;
            Kd = Ka;
            Ks = vec3(1.0);
            Ke = vec3(0.0);
            brightness = 200.0f;
			pos = vPos;
			normalVector = normalize(vNormal);

            //pl1 = (view2 * vec4(pl1,1.0)).xyz;
            //dir = (view2 * vec4(dir,0.0)).xyz;

			Light lights[MAX_LIGHTS];
			numLights = 1;
			Light l1 = Light(vec4(pl1,1.0), Il1,c1,c2,c3,Ia1,180.0f,vec3(1));
            Light l3 = Light(vec4(dir,0.0f), Il3,0.0f,0.0f,0.0f,Ia3,180.0f,vec3(1));
            lights[0] = l3;
            outColor = vec4(shade(lights), 1.);
        }
    </script>

</head>
<body>
<canvas id="glCanvas"></canvas>
<script type="text/javascript"> 

    var State = function() {
        this.outlineWidth = 0.6;
    };
    var state = new State();

    //http://glmatrix.net/docs/module-mat4.html
    var canvas;

    var shaderProgram;
    var projectionLoc, viewLoc, modelLoc, camPosLoc, outlineWidthLoc;
    var colorLoc, positionLoc,normalLoc;

    var perspMat, viewMat, modelMat;

    var meshVertexs;
    var meshIndexs;
    var meshNormals;

    var vertexBuff;
    var indexBuff;
    var normalBuff;

    var camaraPos =[0.0,0.0,-5.0];


    var drag    = false;
    var prevX=0, prevY=0, dX=0, dY=0, rotX=0, rotY=0;

    function mouseDown(e) 
    {
        drag = true;
        prevX = e.pageX;
        prevY = e.pageY;
        e.preventDefault();
    };
 
    function mouseUp(e)
    {
        drag=false;
    };
  
    function mouseMove(e) 
    {
        if (drag)
        {
            dX  =   (e.pageX-prevX)*2*Math.PI/canvas.width,
            dY  =   (e.pageY-prevY)*2*Math.PI/canvas.height;
            rotX += dX;
            if ( Math.abs(rotY+dY) < (Math.PI/2.0) ) rotY+=dY;
            prevX = e.pageX;
            prevY = e.pageY;
            e.preventDefault();
        }
    };

   function eventHandler(e) {
       var keyCode = e.key;

       var forward = [viewMat[2], viewMat[6], viewMat[10]];
       if (forward[2] !== 0 && forward[0] !== 0) {
           forward[1] = 0;
           glMatrix.vec3.normalize(forward,forward);
       }
       var right = [viewMat[0], viewMat[4], viewMat[7]];
       var up = [0.0,1.0,0.0];
       switch (keyCode) {
           case 'w':
               camaraPos[0] += forward[0];
               camaraPos[1] += forward[1];
               camaraPos[2] += forward[2];
                break;
           case 's' :
               camaraPos[0] -= forward[0];
               camaraPos[1] -= forward[1];
               camaraPos[2] -= forward[2];
               break;
           case 'a':
               camaraPos[0] -= right[0];
               camaraPos[1] -= right[1];
               camaraPos[2] -= right[2];
               break;
           case 'd':
               camaraPos[0] += right[0];
               camaraPos[1] += right[1];
               camaraPos[2] += right[2];
               break;
           case 'r':
               camaraPos[0] += up[0];
               camaraPos[1] += up[1];
               camaraPos[2] += up[2];
               break;
           case 'f':
               camaraPos[0] -= up[0];
               camaraPos[1] -= up[1];
               camaraPos[2] -= up[2];

       }
   }

    //Init function
    function init()
    {
        var bunnyObj;
        $.ajax({
            url: "sphere.json",
            dataType: "json",
            success: function(response) {
                bunnyObj = response;

            },
            async: false
        });

        canvas = document.getElementById( "glCanvas" ); 
        canvas.width    = window.innerWidth;
        canvas.height   = window.innerHeight;    
        
        //Context Inicialization
        try 
        {
            gl = canvas.getContext("webgl2");
        } catch (e) 
        {
            alert("Your browser is not webgl2 compatible!!!") ;
            throw "Unable to initialize WebGL2 context";
        }

        //Add events
        canvas.addEventListener( "mousedown", mouseDown, false );
        canvas.addEventListener( "mouseup", mouseUp, false );
        canvas.addEventListener( "mouseout", mouseUp, false );
        canvas.addEventListener( "mousemove", mouseMove, false );
        window.addEventListener("keypress", eventHandler, false);

        //Shader inicialization
        shaderProgram = new ShaderManager( );
        shaderProgram.createShader( document.getElementById( "vs" ).text.trim(), gl.VERTEX_SHADER );
        shaderProgram.createShader( document.getElementById( "fs" ).text.trim(), gl.FRAGMENT_SHADER );
        shaderProgram.createProg( );
        shaderProgram.linkProg( );
        shaderProgram.useProg( );
    
        //Attach Matrices
        projLoc = gl.getUniformLocation(shaderProgram.program, "projection");
        viewLoc = gl.getUniformLocation(shaderProgram.program, "view");
        modelLoc = gl.getUniformLocation(shaderProgram.program, "model");
        camPosLoc = gl.getUniformLocation(shaderProgram.program, "camPos");
        outlineWidthLoc = gl.getUniformLocation(shaderProgram.program, "outlineWidthPos");
    
        //Connect Buffers
        colorLoc      = gl.getAttribLocation(shaderProgram.program, "color");
        positionLoc   = gl.getAttribLocation(shaderProgram.program, "position");
        normalLoc     = gl.getAttribLocation(shaderProgram.program, "normal");
        gl.enableVertexAttribArray(colorLoc);
        gl.enableVertexAttribArray(positionLoc);
        gl.enableVertexAttribArray(normalLoc);

        //Buffer creation
        meshVertexs = bunnyObj.vertexs; //triVertices;
        meshIndexs = bunnyObj.faces; //triFaces;
        meshNormals = bunnyObj.normals;
        vertexBuff= gl.createBuffer ();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuff);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshVertexs),gl.STATIC_DRAW);

        normalBuff = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuff);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(meshNormals),gl.STATIC_DRAW);

        indexBuff= gl.createBuffer ();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuff);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(meshIndexs), gl.STATIC_DRAW);

        //Matrices setup
        perspMat = glMatrix.mat4.create();
        glMatrix.mat4.perspective(perspMat, 45, canvas.width/canvas.height, 1, 10);
        modelMat = glMatrix.mat4.create();
        viewMat = glMatrix.mat4.create();
        glMatrix.mat4.fromTranslation(viewMat, glMatrix.vec3.fromValues(camaraPos[0], camaraPos[1], camaraPos[2]));

        gl.uniformMatrix4fv(projLoc, false, perspMat);
        gl.uniformMatrix4fv(viewLoc, false, viewMat);
        gl.uniform3fv(camPosLoc, glMatrix.vec3.fromValues(camaraPos[0], camaraPos[1], camaraPos[2]));
        gl.uniform1f(outlineWidthLoc, State.outlineWidth);

        //Prepare render
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
        gl.clearDepth(1.0);
    }

    //Draw funtion
    function draw (time) 
    {
        if (!drag) dX=dY=0;
        
        //Matrix updates

        glMatrix.mat4.identity(viewMat);
        glMatrix.mat4.rotate(viewMat,viewMat,rotY,glMatrix.vec3.fromValues(1,0,0));
        glMatrix.mat4.rotate(viewMat,viewMat,rotX,glMatrix.vec3.fromValues(0,1,0));
        glMatrix.mat4.translate(viewMat,viewMat, glMatrix.vec3.fromValues(camaraPos[0], camaraPos[1], camaraPos[2]));





        //glMatrix.mat4.fromYRotation(modelMat, rotX);
       // glMatrix.mat4.rotate(modelMat, modelMat, rotY, glMatrix.vec3.fromValues(1, 0, 0));
  
        //Rendering
        gl.viewport(0.0, 0.0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.uniformMatrix4fv(viewLoc, false, viewMat);
        gl.uniformMatrix4fv(modelLoc, false, modelMat);
        gl.uniform3fv(camPosLoc,glMatrix.vec3.fromValues(camaraPos[0],camaraPos[1],camaraPos[2]));
        gl.uniform1f(outlineWidthLoc, State.outlineWidth);

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuff);

        //https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
        var meshElementSize = 4*(3+3); //4 bytes * (pos + color)
        var meshColorOffset = 4*3; //4 bytes * (pos)
        gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, meshElementSize,   0 ) ;
        gl.vertexAttribPointer(normalLoc,3,gl.FLOAT,false,meshElementSize,0);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false,  meshElementSize, meshColorOffset ) ;

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuff);
        
        gl.drawElements(gl.TRIANGLES, meshIndexs.length , gl.UNSIGNED_SHORT, 0);
        
        gl.flush();
        window.requestAnimationFrame(draw);
    };

    init();
    draw(0);

    $(window).ready(function() {
        var gui = new dat.GUI();
        gui.add(state, 'outlineWidth', 0.1, 1.5);
    });

</script>
</body>
</html>
